#!/usr/bin/env python3
"""Normalize coverage XML paths for Codecov compatibility."""

from __future__ import annotations

import argparse
import sys
import os
from pathlib import Path
import xml.etree.ElementTree as ET


def _relative_subpath(path: Path, base: Path | None) -> Path | None:
    """Return the relative path from base to path if path is within base.

    Handles symlinked directories by attempting comparisons with both the
    user-specified paths and their resolved physical counterparts. The function
    returns ``None`` when the relationship cannot be established without
    traversing ``..`` outside of ``base``.

    Args:
        path: The target path to evaluate.
        base: The base path to compare against.

    Returns:
        The relative path if it exists within the base, otherwise None.
    """

    if base is None:
        return None

    try:
        return path.relative_to(base)
    except ValueError:
        pass

    base_resolved = base.resolve()
    path_resolved = path.resolve()
    try:
        return path_resolved.relative_to(base_resolved)
    except ValueError:
        pass

    rel_str = os.path.relpath(path, base)
    if not rel_str.startswith(".."):
        return Path(rel_str)

    rel_str = os.path.relpath(path_resolved, base_resolved)
    if rel_str.startswith(".."):
        return None
    return Path(rel_str)


def normalize(
    report_path: Path,
    repo_root: Path,
    *,
    coverage_root: Path | None = None,
    coverage_alias: Path | None = None,
    source_dir: Path | None = None,
    path_maps: list[tuple[Path, Path]] | None = None,
) -> tuple[list[str], list[str]]:
    """Normalize filenames and <source> entries within a Cobertura XML report.

    Args:
        report_path: Path to the Cobertura XML generated by gcovr/lcov.
        repo_root: Root of the checked-out repository as seen by Codecov.
        coverage_root: Directory gcovr treated as the project root.
        coverage_alias: Path within repo_root that maps to coverage_root (via
            symlinks). If provided, relative paths are rewritten using this
            alias when they fall outside repo_root.
        source_dir: Directory to emit inside <source>. Defaults to repo_root.
        path_maps: List of tuples mapping paths for normalization.

    Returns:
        A tuple containing missing files (relative to repo_root) and external
        files that reside outside the repository.
    """

    tree = ET.parse(report_path)
    root = tree.getroot()

    # Normalize <source> entries
    sources = root.find("sources")
    if sources is None:
        sources = ET.SubElement(root, "sources")
    else:
        for child in list(sources):
            sources.remove(child)

    normalized_source = str(source_dir or repo_root)
    ET.SubElement(sources, "source").text = normalized_source

    missing: list[str] = []
    external: list[str] = []
    path_maps = path_maps or []
    coverage_root = coverage_root or repo_root
    coverage_root_resolved = coverage_root.resolve()
    repo_root_resolved = repo_root.resolve()

    alias_absolute: Path | None = None
    alias_resolved: Path | None = None
    alias_relative: Path | None = None
    if coverage_alias is not None:
        alias_absolute = coverage_alias
        alias_resolved = coverage_alias.resolve()
        alias_relative = _relative_subpath(alias_absolute, repo_root)
        if alias_relative is None:
            alias_relative = _relative_subpath(alias_resolved, repo_root_resolved)

    coverage_root_relative = _relative_subpath(coverage_root, repo_root)
    if coverage_root_relative is None:
        coverage_root_relative = _relative_subpath(
            coverage_root_resolved, repo_root_resolved
        )

    repo_relative_from_coverage = _relative_subpath(repo_root, coverage_root)
    if repo_relative_from_coverage is None:
        repo_relative_from_coverage = _relative_subpath(
            repo_root_resolved, coverage_root_resolved
        )

    def _usable_prefix(prefix: Path | None) -> Path | None:
        if prefix is None:
            return None
        if not prefix.parts:
            return None
        if prefix == Path("."):
            return None
        return prefix

    repo_prefix = _usable_prefix(repo_relative_from_coverage)
    for cls in root.findall(".//class"):
        filename = cls.get("filename")
        if not filename:
            continue

        path = Path(filename)
        relative: Path | None = None
        absolute_candidate: Path | None = None

        if not path.is_absolute():
            base_candidates: list[Path] = [path]

            if repo_prefix is not None:
                try:
                    stripped = path.relative_to(repo_prefix)
                    if stripped != path:
                        base_candidates.insert(0, stripped)
                except ValueError:
                    pass

            for base_candidate in base_candidates:
                if alias_relative is not None:
                    candidate_relative = alias_relative / base_candidate
                elif coverage_root_relative is not None:
                    candidate_relative = coverage_root_relative / base_candidate
                else:
                    candidate_relative = base_candidate

                candidate_path = repo_root / candidate_relative
                candidate_resolved = (repo_root_resolved / candidate_relative).resolve()

                relative = candidate_relative
                absolute_candidate = candidate_resolved

                if candidate_path.exists() or candidate_resolved.exists():
                    break
        else:
            absolute_path = path
            relative = _relative_subpath(absolute_path, repo_root)
            if relative is None:
                relative = _relative_subpath(absolute_path, repo_root_resolved)

            if relative is None and alias_absolute is not None:
                subpath = _relative_subpath(absolute_path, alias_absolute)
                if subpath is None and alias_resolved is not None:
                    subpath = _relative_subpath(absolute_path, alias_resolved)
                if subpath is not None:
                    if alias_relative is not None:
                        relative = alias_relative / subpath
                    else:
                        relative = subpath

            if relative is None and coverage_root_relative is not None:
                subpath = _relative_subpath(absolute_path, coverage_root)
                if subpath is None:
                    subpath = _relative_subpath(absolute_path, coverage_root_resolved)
                if subpath is not None:
                    relative = coverage_root_relative / subpath

            if relative is None and path_maps:
                for from_root, alias_root in path_maps:
                    subpath = _relative_subpath(absolute_path, from_root)
                    if subpath is None:
                        subpath = _relative_subpath(absolute_path, from_root.resolve())
                    if subpath is None:
                        continue

                    map_alias_relative = _relative_subpath(alias_root, repo_root)
                    if map_alias_relative is None:
                        map_alias_relative = _relative_subpath(
                            alias_root.resolve(), repo_root_resolved
                        )
                    if map_alias_relative is None:
                        continue

                    relative = map_alias_relative / subpath
                    break

            if relative is None:
                external.append(absolute_path.as_posix())
                continue

            absolute_candidate = (repo_root_resolved / relative).resolve()

        cls.set("filename", relative.as_posix())

        candidate = repo_root / relative
        candidate_resolved = absolute_candidate
        if not candidate.exists() and not candidate_resolved.exists():
            missing.append(relative.as_posix())

    tree.write(report_path)
    return missing, external


def parse_args(argv: list[str]) -> argparse.Namespace:
    """Parse command-line arguments.

    Args:
        argv: List of command-line arguments.

    Returns:
        Parsed arguments as a Namespace object.
    """
    parser = argparse.ArgumentParser(
        description=(
            "Normalize Cobertura XML output for Codecov so that file paths "
            "match the repository checkout."
        )
    )
    parser.add_argument(
        "report",
        type=Path,
        help=(
            "Path to the Cobertura XML report "
            "(e.g., phlex-build/coverage.xml)"
        ),
    )
    parser.add_argument(
        "--repo-root",
        type=Path,
        default=Path.cwd(),
        help=(
            "Repository root as seen by Codecov "
            "(default: current directory)"
        ),
    )
    parser.add_argument(
        "--coverage-root",
        type=Path,
        default=None,
        help=(
            "Root used when gcovr generated the report "
            "(default: --repo-root)"
        ),
    )
    parser.add_argument(
        "--coverage-alias",
        type=Path,
        default=None,
        help=(
            "Path within --repo-root that should represent the coverage "
            "root when rewriting filenames"
        ),
    )
    parser.add_argument(
        "--source-dir",
        type=Path,
        default=None,
        help=(
            "Directory to store inside <source> "
            "(default: same as --repo-root)"
        ),
    )
    parser.add_argument(
        "--path-map",
        action="append",
        default=[],
        metavar="FROM=TO",
        help=(
            "Map files under directory FROM to a location TO within the "
            "repository before normalization. FROM may be absolute or "
            "relative to --repo-root; TO may be absolute or relative to "
            "--repo-root. This option can be specified multiple times."
        ),
    )
    return parser.parse_args(argv)


def main(argv: list[str]) -> int:
    """Main entry point for the script.

    Args:
        argv: List of command-line arguments.

    Returns:
        Exit code indicating success or failure.
    """
    args = parse_args(argv)
    report = args.report.resolve()
    repo_root = args.repo_root.absolute()
    coverage_root = (
        args.coverage_root.absolute() if args.coverage_root else repo_root
    )
    coverage_alias = (
        args.coverage_alias.absolute() if args.coverage_alias else None
    )
    source_dir = args.source_dir.absolute() if args.source_dir else repo_root

    path_maps: list[tuple[Path, Path]] = []
    for mapping in args.path_map:
        if "=" not in mapping:
            raise SystemExit(
                f"Invalid --path-map '{mapping}'. Expected format FROM=TO."
            )
        src_raw, dst_raw = mapping.split("=", 1)
        src_path = Path(src_raw)
        if not src_path.is_absolute():
            src_path = (repo_root / src_path).resolve()
        else:
            src_path = src_path.resolve()

        dst_path = Path(dst_raw)
        if not dst_path.is_absolute():
            dst_path = (repo_root / dst_path).resolve()
        else:
            dst_path = dst_path.resolve()

        path_maps.append((src_path, dst_path))

    missing, external = normalize(
        report,
        repo_root,
        coverage_root=coverage_root,
        coverage_alias=coverage_alias,
        source_dir=source_dir,
        path_maps=path_maps,
    )

    if external:
        joined = "\n".join(f"  - {name}" for name in external)
        sys.stderr.write(
            "Coverage XML references files outside the repository root. "
            "Adjust gcovr filters or excludes to omit external dependencies:\n"
            f"{joined}\n"
        )
        return 1

    if missing:
        joined = "\n".join(f"  - {name}" for name in missing)
        sys.stderr.write(
            "Coverage XML references files that do not exist in the "
            "repository:\n"
            f"{joined}\n"
        )
        return 1

    print("Coverage XML paths normalized successfully.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
